% 
% Author: D. Rodriguez-Galiano / A. A. Del-Barrio / G. Botella / D. Cuesta
% Date: 2020/04/07
% Function: step2_add_header_in_bitstream
% 
% Purpose: Adds the coordinate header (CPS) into the bitstream.
% 

clear all
clc

%%% VARIABLE DECLARATIONS                        %%%
%%% Modify values according to user requirements %%%

% Path and filename where the bitstream of the source video is located.
% Must be .bin extension.
BITSTREAM_FILE_PATH = '/path/to/bitstream-video-modified/bitstream.bin';

% Path and filename where the modified bitstream with the new CPS NAL will
% be located.
% Must be .bin extension.
HIDDEN_MSG_BITSTREAM_FILE_PATH = '/path/to/bitstream-video-modified/extraheader_bitstream.bin';

% Path and filename where coordinates are located.
COORDINATES = readCoordinates('/path/to/video-modified/coordinates.txt');

% One bit is defined by three coordinates (frame, x, y).
COORDINATES_PER_BIT = 3;

% FD_NUT NAL that defines the start of the CPS.
CUSTOM_HEADER_PATTERN = [0; 0; 0; 1; 76; 1; 0; 0; 3; 1];

% Size in bytes of the FD_NUL NAL definition.
CUSTOM_HEADER_PATTERN_SIZE = 10;

% Number of previous headers to CPS NAL (video, sequence and frame)
HEADER_NUMS = 3; 

%%% END VARIABLE DECLARATIONS %%%

%%% EXECUTION %%%

% Reads coordinates. Each tuple is a (frame, x, y) 
% structure. 
% In this version, each coordinate must be added in a 2-bytes size value.
% The maximum value is 65535d o 0xFFFFF.
[msg_size, ~] = size(COORDINATES);

tic

pos = 1;
for i=1 : msg_size
    for j=1 : COORDINATES_PER_BIT
        valor = COORDINATES(i, j);
        message(pos, 1) = valor;
        pos=pos+1;
    end
end

% Prints the header generation time. Not including the writing process.
t=toc;
disp(datestr(datenum(0,0,0,0,0,t),'HH:MM:SS'))

%%%%%%%%%%%%%%%

% Reads the bitstream (generated by the HEVC encoding process).
fid = fopen(BITSTREAM_FILE_PATH, 'r');
bytelist = fread(fid, '*ubit8');
fclose(fid);

[bytelist_length, ~] = size(bytelist);

% Identifies the position where CPS will be added.
% It should be after the VPS, SPS and PPS NALs and before the first IDR.
% Offset 1: VPS
% Offset 2: SPS
% Offset 3: PPS
% Offset 4: NAL IDR <- where picture data start
matrix_offsets_idr_nal_slides = strfind(bytelist',[00 00 01]);
offset_first_data_NAL = matrix_offsets_idr_nal_slides(HEADER_NUMS+1);

% The length of the three first NALS is the offset of the first NAL IDR - 1
% and the length of the data is from the NAL IDR offset to the end of the 
% bitstream.
header_lenght = offset_first_data_NAL-1;
data_lenght = bytelist_length - header_lenght;

% Takes the header matrix
for i=1 : header_lenght
    header_bytelist(i, 1) = bytelist(i);
end

% Takes the data matrix
for i=1 : data_lenght
    data_bytelist(i, 1) = bytelist(offset_first_data_NAL-1+i);
end

% Generates the bitstream with the new CPS NAL.
fid_new = fopen(HIDDEN_MSG_BITSTREAM_FILE_PATH,'w');

% Adds the VPS, SPS and PPS NALs.
fwrite(fid_new, header_bytelist);

% Adds the custom NAL (CPS).
fwrite(fid_new, CUSTOM_HEADER_PATTERN);
% Adds the coordinates in two by two bytes little-endian format.
fwrite(fid_new, message, 'uint16');

% Adds the closing pattern 0xFFFF.
fwrite(fid_new, 65535, 'uint16');

% Adds the information related with pictures.
fwrite(fid_new, data_bytelist);

fclose(fid_new);

return;

%%% END EXECUTION %%%
